/*
 * Copyright (C) 2021 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <stdint.h>
#include <stdio.h>
#include <string>
#include <vector>

#include "perfetto/ext/base/file_utils.h"
#include "perfetto/ext/base/scoped_file.h"
#include "perfetto/ext/base/string_view.h"
#include "perfetto/protozero/proto_utils.h"
#include "perfetto/protozero/scattered_heap_buffer.h"
#include "protos/perfetto/common/builtin_clock.pbzero.h"
#include "protos/perfetto/trace/clock_snapshot.pbzero.h"
#include "protos/perfetto/trace/trace.pbzero.h"
#include "protos/perfetto/trace/trace_packet.pbzero.h"

// Merges a host and guest trace. The host and guest traces must both contain
// the new TSC clocksource, and the host trace must also contain at least one
// clocksnapshot mapping the guest TSC clocksource to the host TSC clocksource.
// The clock IDs of the host clocks will all be offset by
// +HOST_GUEST_CLOCK_ID_OFFSET so they don't conflict with the guest clocks,
// whose IDs will not change. The host/guest TSC map clocksnapshot must thus
// have the guest clock with the normal TSC clock ID (9) and the host clock
// offset by +HOST_GUEST_CLOCK_ID_OFFSET (9+HOST_GUEST_CLOCK_ID_OFFSET).

namespace perfetto {
namespace vm_merge {
namespace {

struct TscGuestHostOffset {
  uint64_t guest_tsc;
  uint64_t host_tsc;
  uint64_t tsc_frequency;
};

void WriteToFile(const std::string& out, const char* path) {
  PERFETTO_CHECK(!remove(path) || errno == ENOENT);
  auto out_fd = base::OpenFile(path, O_RDWR | O_CREAT, 0666);
  if (!out_fd) {
    PERFETTO_FATAL("Unable to open ouput file %s", path);
  }
  if (base::WriteAll(out_fd.get(), out.data(), out.size()) !=
      static_cast<ssize_t>(out.size())) {
    PERFETTO_FATAL("Failed to WriteAll to output file %s", path);
  }
}

void CopyField(protozero::Message* out, const protozero::Field& field) {
  using protozero::proto_utils::ProtoWireType;
  switch (field.type()) {
    case ProtoWireType::kVarInt: {
      out->AppendVarInt(field.id(), field.as_uint64());
      break;
    }
    case ProtoWireType::kLengthDelimited: {
      out->AppendBytes(field.id(), field.as_bytes().data,
                       field.as_bytes().size);
      break;
    }
    case ProtoWireType::kFixed32: {
      out->AppendFixed(field.id(), field.as_uint32());
      break;
    }
    case ProtoWireType::kFixed64: {
      out->AppendFixed(field.id(), field.as_uint64());
      break;
    }
  }
}

// Offset between host and guest clock ids. If this is changed we also need to
// adjust the host trace producer that generates the mapping clocksnapshot. The
// reason this might be changed would be if there are more than this number of
// builtin clock snapshots.
// If there are ever > 32 builtin clocksources, this approach won't work, and
// we will have to rethink the host/guest merge strategy (or how we use clock
// ids).
const uint32_t HOST_GUEST_CLOCK_ID_OFFSET = 32;

/// For any host clock id < 64, offset the clock id by
/// HOST_GUEST_CLOCK_ID_OFFSET to make it a guest clock id (meaning, a new
/// builtin clock that doesn't conflict with the existing guest clock ids.
uint32_t HostToGuestClockId(uint32_t guest_clock_id) {
  if (guest_clock_id < 64) {
    return guest_clock_id + HOST_GUEST_CLOCK_ID_OFFSET;
  }

  return guest_clock_id;
}

/// Scale a TSC clocksource timestamp by the tsc frequency. Perfetto itself
/// only currently supports integer clock scaling, so until that support is
/// added to perfetto (and released in the web ui), we scale in the merge tool.
/// The scale value comes from the clock snapshot generated by the host.
uint64_t ScaleTscTimestamp(uint64_t timestamp, uint64_t tsc_frequency) {
  uint64_t q = timestamp / tsc_frequency;
  uint64_t r = timestamp % tsc_frequency;
  const uint64_t NS_IN_SECS = 1000000000;
  return (q * NS_IN_SECS) + (r * NS_IN_SECS / tsc_frequency);
}

/// We can identify a TSC offset snapshot because it contains both a guest TSC
/// clock id (BUILTIN_CLOCK_TSC) as well as the the pre-adjusted host TSC clock
/// id (BUILTIN_CLOCK_TSC+HOST_GUEST_CLOCK_ID_OFFSET).
bool IsTscOffsetSnapshot(const uint8_t* data, size_t size) {
  protos::pbzero::ClockSnapshot::Decoder snapshot(data, size);
  bool found_host_tsc = false;
  bool found_guest_tsc = false;
  for (auto clock_it = snapshot.clocks(); clock_it; ++clock_it) {
    protos::pbzero::ClockSnapshot_Clock::Decoder clock(*clock_it);
    if (clock.clock_id() == protos::pbzero::BuiltinClock::BUILTIN_CLOCK_TSC) {
      found_guest_tsc = true;
    } else if (clock.clock_id() ==
               HostToGuestClockId(
                   protos::pbzero::BuiltinClock::BUILTIN_CLOCK_TSC)) {
      found_host_tsc = true;
    }
  }
  return found_host_tsc && found_guest_tsc;
}

/// Iterate through all the host clock snapshots until we find the TSC offset
/// snapshot and extract the TSC offset information from it. The TSC offset
/// information is a mapping of guest and host TSC values (ideally near in time
/// to when the trace occurred), as well as the TSC frequency, which we get
/// from the unit_multiplier_ns field. It's not really a unit_multiplier_ns
/// because we treat it as the Hz frequency of the TSC, this should be changed
/// when we support a floating point multiplier.
TscGuestHostOffset GetTscOffsetFromHostTrace(base::StringView host_raw) {
  protos::pbzero::Trace::Decoder guest_trace(
      reinterpret_cast<const uint8_t*>(host_raw.data()), host_raw.size());
  for (auto packet_it = guest_trace.packet(); packet_it; ++packet_it) {
    protozero::ProtoDecoder packet(*packet_it);
    for (auto field = packet.ReadField(); field.valid();
         field = packet.ReadField()) {
      if ((field.id() !=
           protos::pbzero::TracePacket::kClockSnapshotFieldNumber) ||
          (!IsTscOffsetSnapshot(field.data(), field.size()))) {
        continue;
      }

      TscGuestHostOffset offset{};
      protos::pbzero::ClockSnapshot::Decoder snapshot(field.data(),
                                                      field.size());
      for (auto clock_it = snapshot.clocks(); clock_it; ++clock_it) {
        protos::pbzero::ClockSnapshot_Clock::Decoder clock(*clock_it);
        if (clock.clock_id() ==
            protos::pbzero::BuiltinClock::BUILTIN_CLOCK_TSC) {
          offset.guest_tsc = clock.timestamp();
        } else if (clock.clock_id() ==
                   HostToGuestClockId(
                       protos::pbzero::BuiltinClock::BUILTIN_CLOCK_TSC)) {
          offset.host_tsc = clock.timestamp();
          offset.tsc_frequency = clock.unit_multiplier_ns();
        }
      }
      return offset;
    }
  }
  PERFETTO_FATAL(
      "Unable to find host->guest TSC offset ClockSnapshot in host trace");
}

/// We add a new mapping snapshot so it can exist before any of the host packets
void AddGuestHostTscMappingSnapshot(protos::pbzero::TracePacket* packet,
                                    TscGuestHostOffset tsc_offset) {
  auto snapshot = packet->set_clock_snapshot();
  auto host_tsc = snapshot->add_clocks();
  host_tsc->set_clock_id(
      HostToGuestClockId(protos::pbzero::BuiltinClock::BUILTIN_CLOCK_TSC));
  host_tsc->set_timestamp(
      ScaleTscTimestamp(tsc_offset.host_tsc, tsc_offset.tsc_frequency));
  auto guest_tsc = snapshot->add_clocks();
  guest_tsc->set_clock_id(protos::pbzero::BuiltinClock::BUILTIN_CLOCK_TSC);
  guest_tsc->set_timestamp(
      ScaleTscTimestamp(tsc_offset.guest_tsc, tsc_offset.tsc_frequency));
}

/// Main merge function, returns the output trace as a string.
std::string Merge(base::StringView host_raw, base::StringView guest_raw) {
  protozero::HeapBuffered<protos::pbzero::Trace> output;

  // Read the host trace to get the offset snapshot info
  auto tsc_offset = GetTscOffsetFromHostTrace(host_raw);

  // First we add the guest trace. We don't have to change the clock ids, but
  // we do have to scale the TSC clock snapshots by the TSC frequency.
  protos::pbzero::Trace::Decoder guest_trace(
      reinterpret_cast<const uint8_t*>(guest_raw.data()), guest_raw.size());
  for (auto packet_it = guest_trace.packet(); packet_it; ++packet_it) {
    protozero::ProtoDecoder packet(*packet_it);
    protos::pbzero::TracePacket* packet_out = output->add_packet();

    for (auto field = packet.ReadField(); field.valid();
         field = packet.ReadField()) {
      if (field.id() ==
          protos::pbzero::TracePacket::kClockSnapshotFieldNumber) {
        // Scale TSC clock snapshot
        auto snapshot_out = packet_out->set_clock_snapshot();
        protos::pbzero::ClockSnapshot::Decoder snapshot(field.data(),
                                                        field.size());
        for (auto clock_it = snapshot.clocks(); clock_it; ++clock_it) {
          protos::pbzero::ClockSnapshot_Clock::Decoder clock(*clock_it);
          auto clock_out = snapshot_out->add_clocks();
          if (clock.clock_id() ==
              protos::pbzero::BuiltinClock::BUILTIN_CLOCK_TSC) {
            clock_out->set_timestamp(
                ScaleTscTimestamp(clock.timestamp(), tsc_offset.tsc_frequency));
          } else {
            clock_out->set_timestamp(clock.timestamp());
          }
          clock_out->set_clock_id(clock.clock_id());
        }

      } else {
        CopyField(packet_out, field);
      }
    }
  }

  // Add the mapping snapshot before any host packets
  AddGuestHostTscMappingSnapshot(output->add_packet(), tsc_offset);

  // Next we read the host trace. We change all the clock ids of the host
  // trace so they don't conflict with the guest clock ids. We also scale
  // the TSC clock snapshots by the TSC frequency.
  protos::pbzero::Trace::Decoder host_trace(
      reinterpret_cast<const uint8_t*>(host_raw.data()), host_raw.size());
  for (auto packet_it = host_trace.packet(); packet_it; ++packet_it) {
    protozero::ProtoDecoder packet(*packet_it);
    protos::pbzero::TracePacket* packet_out = output->add_packet();
    bool found_clock_id = false;

    for (auto field = packet.ReadField(); field.valid();
         field = packet.ReadField()) {
      switch (field.id()) {
        case protos::pbzero::TracePacket::kTimestampClockIdFieldNumber: {
          // Change host clock id
          packet_out->set_timestamp_clock_id(
              HostToGuestClockId(field.as_uint32()));
          found_clock_id = true;
          break;
        }
        case protos::pbzero::TracePacket::kClockSnapshotFieldNumber: {
          // We don't include the original offset snapshots in the combined
          // trace
          if (IsTscOffsetSnapshot(field.data(), field.size())) {
            continue;
          }

          auto snapshot_out = packet_out->set_clock_snapshot();

          protos::pbzero::ClockSnapshot::Decoder snapshot(field.data(),
                                                          field.size());
          for (auto clock_it = snapshot.clocks(); clock_it; ++clock_it) {
            protos::pbzero::ClockSnapshot_Clock::Decoder clock(*clock_it);
            auto clock_out = snapshot_out->add_clocks();
            if (clock.clock_id() ==
                protos::pbzero::BuiltinClock::BUILTIN_CLOCK_TSC) {
              clock_out->set_timestamp(ScaleTscTimestamp(
                  clock.timestamp(), tsc_offset.tsc_frequency));
            } else {
              clock_out->set_timestamp(clock.timestamp());
            }
            clock_out->set_clock_id(HostToGuestClockId(clock.clock_id()));
          }
          break;
        }
        case protos::pbzero::TracePacket::kServiceEventFieldNumber: {
          // Because we're translating our host time to the guest time,
          // including host service events here can cause guest events to be
          // filtered out. So we just don't include ServiceEvent packet fields.
          break;
        }
        default: {
          CopyField(packet_out, field);
        }
      }
    }

    // add a clock_id to all host packets that don't have one
    if (!found_clock_id) {
      packet_out->set_timestamp_clock_id(HostToGuestClockId(
          protos::pbzero::BuiltinClock::BUILTIN_CLOCK_BOOTTIME));
    }
  }

  return output.SerializeAsString();
}

int Main(int argc, const char** argv) {
  if (argc != 4) {
    PERFETTO_FATAL("Usage: %s <host trace> <guest trace> <output>", argv[0]);
  }
  const char* host_path = argv[1];
  const char* guest_path = argv[2];
  const char* out_path = argv[3];

  std::string host_raw;
  if (!base::ReadFile(host_path, &host_raw)) {
    PERFETTO_FATAL("ReadFile failed on host trace %s", host_path);
  }

  std::string guest_raw;
  if (!base::ReadFile(guest_path, &guest_raw)) {
    PERFETTO_FATAL("ReadFile failed on guest trace %s", guest_path);
  }

  std::string raw_out =
      Merge(base::StringView(host_raw), base::StringView(guest_raw));
  WriteToFile(raw_out, out_path);
  return 0;
}

}  // namespace
}  // namespace vm_merge
}  // namespace perfetto

int main(int argc, const char** argv) {
  return perfetto::vm_merge::Main(argc, argv);
}

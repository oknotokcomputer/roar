/* automatically generated by rust-bindgen
See instructions from: https://rust-lang.github.io/rust-bindgen/print.html

Original library: https://github.com/avaneev/r8brain-free-src

To generate bindings:
1. go to the r8brain-free-src location. In my case it'll be:

    cd C:\src\crosvm\third_party\r8brain\

2. Run bindgen and put the binding file in the win_audio r8brain_sys directory"

    bindgen .\DLL\r8bsrc.h -o ..\..\platform\crosvm\win_audio\src\r8brain_sys\binding.rs -- -x c++
*/

#[doc = " Resampler object handle."]
pub type CR8BResampler = *mut ::std::os::raw::c_void;
#[doc = "< 16-bit precision resampler."]
#[doc = "<"]
pub const ER8BResamplerRes_r8brr16: ER8BResamplerRes = 0;
#[doc = "< 16-bit precision resampler for impulse responses."]
#[doc = "<"]
pub const ER8BResamplerRes_r8brr16IR: ER8BResamplerRes = 1;
#[doc = "< 24-bit precision resampler (including 32-bit floating"]
#[doc = "< point)."]
#[doc = "<"]
pub const ER8BResamplerRes_r8brr24: ER8BResamplerRes = 2;
#[doc = " Possible resampler object resolutions."]
pub type ER8BResamplerRes = i32;
extern "C" {
    #[doc = " Function creates a new linear-phase resampler object."]
    #[doc = ""]
    #[doc = " @param SrcSampleRate Source signal sample rate. Both sample rates can"]
    #[doc = " be specified as a ratio, e.g. SrcSampleRate = 1.0, DstSampleRate = 2.0."]
    #[doc = " @param DstSampleRate Destination signal sample rate."]
    #[doc = " @param MaxInLen The maximal planned length of the input buffer (in samples)"]
    #[doc = " that will be passed to the resampler. The resampler relies on this value as"]
    #[doc = " it allocates intermediate buffers. Input buffers longer than this value"]
    #[doc = " should never be supplied to the resampler. Note that the resampler may use"]
    #[doc = " the input buffer itself for intermediate sample data storage."]
    #[doc = " @param Res Resampler's required resolution."]
    pub fn r8b_create(
        SrcSampleRate: f64,
        DstSampleRate: f64,
        MaxInLen: ::std::os::raw::c_int,
        ReqTransBand: f64,
        Res: ER8BResamplerRes,
    ) -> CR8BResampler;
}
extern "C" {
    #[doc = " Function deletes a resampler previously created via the r8b_create()"]
    #[doc = " function."]
    #[doc = ""]
    #[doc = " @param rs Resampler object to delete."]
    pub fn r8b_delete(rs: CR8BResampler);
}
extern "C" {
    #[doc = " Function clears (resets) the state of the resampler object and returns it"]
    #[doc = " to the state after construction. All input data accumulated in the"]
    #[doc = " internal buffer of this resampler object so far will be discarded."]
    #[doc = ""]
    #[doc = " @param rs Resampler object to clear."]
    pub fn r8b_clear(rs: CR8BResampler);
}
extern "C" {
    #[doc = " Function performs sample rate conversion."]
    #[doc = ""]
    #[doc = " If the source and destination sample rates are equal, the resampler will do"]
    #[doc = " nothing and will simply return the input buffer unchanged."]
    #[doc = ""]
    #[doc = " You do not need to allocate an intermediate output buffer for use with this"]
    #[doc = " function. If required, the resampler will allocate a suitable intermediate"]
    #[doc = " output buffer itself."]
    #[doc = ""]
    #[doc = " @param rs Resampler object that performs processing."]
    #[doc = " @param ip0 Input buffer. This buffer may be used as output buffer by this"]
    #[doc = " function."]
    #[doc = " @param l The number of samples available in the input buffer."]
    #[doc = " @param[out] op0 This variable receives the pointer to the resampled data."]
    #[doc = " This pointer may point to the address within the \"ip0\" input buffer, or to"]
    #[doc = " *this object's internal buffer. In real-time applications it is suggested"]
    #[doc = " to pass this pointer to the next output audio block and consume any data"]
    #[doc = " left from the previous output audio block first before calling the"]
    #[doc = " r8b_process() function again. The buffer pointed to by the \"op0\" on return"]
    #[doc = " may be owned by the resampler, so it should not be freed by the caller."]
    #[doc = " @return The number of samples available in the \"op0\" output buffer. If the"]
    #[doc = " data from the output buffer \"op0\" is going to be written to a bigger output"]
    #[doc = " buffer, it is suggested to check the returned number of samples so that no"]
    #[doc = " overflow of the bigger output buffer happens."]
    pub fn r8b_process(
        rs: CR8BResampler,
        ip0: *mut f64,
        l: ::std::os::raw::c_int,
        op0: *mut *mut f64,
    ) -> ::std::os::raw::c_int;
}
